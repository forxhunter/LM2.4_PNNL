/*****************************************************************************
*
* Copyright (c) 2000 - 2014, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                      avtLatticeMicrobesFileFormat.C                       //
// ************************************************************************* //

#include <avtLatticeMicrobesFileFormat.h>

#include <string>
#include <vector>
#include <sstream>
#include <string>
#include <cstring>
#include <cstdio>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>

#include <hdf5.h>
#include <hdf5_hl.h>

//#define DEBUG
//#ifdef DEBUG
//  #define DEBUGSTREAM(X) debug1 << X << endl
//#endif



using     std::string;
using     std::map;




// Forward declarations of iterator functions
herr_t findLongest(hid_t group_id, const char *member_name, void *op_data);
herr_t parseParameter(hid_t location_id, const char *attr_name, const H5A_info_t *ainfo, void *op_data);


// Initialize static variables
int avtLatticeMicrobesFileFormat::readerCounts = 0;

// ****************************************************************************
//  Method: avtLatticeMicrobesFileFormat constructor
//
//  Programmer: jpeterson -- generated by xml2avt
//  Creation:   Wed Jan 28 16:20:52 PST 2015
//
// ****************************************************************************


avtLatticeMicrobesFileFormat::avtLatticeMicrobesFileFormat(const char *_filename)
    : avtMTMDFileFormat(_filename)
{
	cout << "Constructing..." << endl;

    // Increment the number of readers
	readerCounts++;
    cout << "Active readers: " << readerCounts << endl;

    // INITIALIZE DATA MEMBERS
    // Set the flag for whether this is initialized or not
    initialized = false;
    // Describe whether the LM file has simulation data or just the initial timestep
    hasSimulationData = false;

    // File information
    file              = H5I_INVALID_HID;
    filename          = string(_filename);
    parametersGroup   = H5I_INVALID_HID;
    modelGroup        = H5I_INVALID_HID;
    simulationsGroup  = H5I_INVALID_HID;
    numberSimulations = 0;
    replicates        = 0;
    numberTimesteps   = 0;


    // Set the lattice data so that it need only be read once
    latticeXSize     = 0;
    latticeYSize     = 0;
    latticeZSize     = 0;
    latticeSpacing   = -1.0f;
    latticeSpacing   = -1.0f;
    numberSpecies    = 0;
    numberReactions  = 0;
    numberSiteTypes  = 0;
    particlesPerSite = 0;


    // Check if the HDF5 library linked to this plugin supports 
    //  the required encode/decode operations
    if(!sufficientLibraryCapabilities()) {
      EXCEPTION1(InvalidDBTypeException, "HDF5 library did not support operations needed by the Lattice Microbes file reader.");
    }

//    int j = 0; 
//    for(int i = 0; i < 100000; i++) j++;
//    cout << j << endl;

    cout << "Constructed" << endl;
}


// Overridden so that we can use a custom Initialization function
void avtLatticeMicrobesFileFormat::ActivateTimestep()
{
    cout << "Activating Timestep..." << endl;
    Initialize();
	cout << "Timestep activated" << endl;
}

void avtLatticeMicrobesFileFormat::Initialize()
{
    if(!initialized) {
      cout << "  Initializing..." << endl;
      // Check that the file is valid
      cout << "    Checking file validity..." << endl;
      char buffer[64] = "";
      if(!(this->isFileValid(this->filename.c_str(), buffer, 64))) {
        initialized = false;
        EXCEPTION1(InvalidDBTypeException, buffer);
      }

      // Set up property list so that it closes file hard
      hid_t fileProperties;
      HDF5_EXCEPTION_CALL(fileProperties,H5Pcreate(H5P_FILE_ACCESS));
      HDF5_EXCEPTION_CHECK(H5Pset_fclose_degree(fileProperties, H5F_CLOSE_STRONG));

      // Open file
      cout << "    Opening file: '" << filename.c_str() << "'..." << endl;
      cout << "     FN: " << file << endl;
      
      //file = H5Fopen(filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
      HDF5_EXCEPTION_CALL(file,H5Fopen(filename.c_str(), H5F_ACC_RDONLY, fileProperties));
     
      cout << "      " << file << endl;
      if(file < 0) {
        H5Eprint1(stdout);
        EXCEPTION1(InvalidDBTypeException, "Failed opening Lattice Microbes file using HDF5.");
      }
      // Open the properties list //
      cout << "    Testing user block..." << endl;
      hid_t creationProperties;
      hsize_t userBlockSize;
      HDF5_EXCEPTION_CALL(creationProperties,H5Fget_create_plist(file));
      HDF5_EXCEPTION_CHECK(H5Pget_userblock(creationProperties, &userBlockSize));
      if(userBlockSize < 4) {
        EXCEPTION1(InvalidVariableException, "User block incorrect size in Lattice Microbes file.");
      }
      // Check the LM version number
      cout << "    Checking version number..." << endl;
      unsigned int version;
      HDF5_EXCEPTION_CHECK(H5LTget_attribute_uint(file, "/", "formatVersion", &version));
      if( version < LM_SUPPORTED_VERSION) {
        EXCEPTION1(InvalidVariableException, "Unsupported Lattice Microbes file version.");
      }
      // Close properties //
      HDF5_EXCEPTION_CHECK(H5Pclose(creationProperties));

      // Open group handles
      cout << "    Opening group handles..." << endl;
      HDF5_EXCEPTION_CALL(parametersGroup  , H5Gopen2(file, "/Parameters", H5P_DEFAULT));
      HDF5_EXCEPTION_CALL(modelGroup       , H5Gopen2(file, "/Model", H5P_DEFAULT));
      HDF5_EXCEPTION_CALL(simulationsGroup , H5Gopen2(file, "/Simulations", H5P_DEFAULT));
      if(parametersGroup < 0 || modelGroup < 0 || simulationsGroup < 0) {
        EXCEPTION1(InvalidVariableException, "Malformed Lattice Microbes file: couldn't open one or more of {'Parameters','Model','Simulations'}.");
      }
      HDF5_EXCEPTION_CHECK(H5Gget_num_objs(simulationsGroup, &numberSimulations));
      if(numberSimulations < 1) {
        // No simulation data was present, just open the inital timestep data
        hasSimulationData = false;
        replicates = 0;
      } else {
        hasSimulationData = true;
        replicates = numberSimulations;
      }

      // Read information about all the parametesr
      cout << "    Reading parameters..." << endl;
      if(H5Lexists(file, "/Model/Diffusion", H5P_DEFAULT)) {
        HDF5_EXCEPTION_CHECK(H5LTget_attribute_uint(file,   "/Model/Diffusion", "numberSpecies",    &numberSpecies));
        HDF5_EXCEPTION_CHECK(H5LTget_attribute_uint(file,   "/Model/Diffusion", "numberReactions",  &numberReactions));
        HDF5_EXCEPTION_CHECK(H5LTget_attribute_uint(file,   "/Model/Diffusion", "numberSiteTypes",  &numberSiteTypes));
        HDF5_EXCEPTION_CHECK(H5LTget_attribute_double(file, "/Model/Diffusion", "latticeSpacing",   &latticeSpacing));
        HDF5_EXCEPTION_CHECK(H5LTget_attribute_uint(file,   "/Model/Diffusion", "latticeXSize",     &latticeXSize));
        HDF5_EXCEPTION_CHECK(H5LTget_attribute_uint(file,   "/Model/Diffusion", "latticeYSize",     &latticeYSize));
        HDF5_EXCEPTION_CHECK(H5LTget_attribute_uint(file,   "/Model/Diffusion", "latticeZSize",     &latticeZSize));
        HDF5_EXCEPTION_CHECK(H5LTget_attribute_uint(file,   "/Model/Diffusion", "particlesPerSite", &particlesPerSite));
		wordsPerSite = particlesPerSite/PARTICLES_PER_WORD;
        cout << "      NS: " << numberSpecies << endl;
        cout << "      NR: " << numberReactions << endl;
        cout << "      ST: " << numberSiteTypes << endl;
        cout << "      LS: " << latticeSpacing << endl;
        cout << "      LX: " << latticeXSize << endl;
        cout << "      LY: " << latticeYSize << endl;
        cout << "      LZ: " << latticeZSize << endl;
        cout << "      PPS: " << particlesPerSite << endl;
      } else {
        EXCEPTION1(InvalidVariableException, "Malformed Lattice Microbes file: couldn't open Diffusion model");
      }

      // Read simulation parameters
      //map<string,string> parameterMap;
      
      hsize_t n = 0;
      HDF5_EXCEPTION_CHECK(H5Aiterate2(parametersGroup, H5_INDEX_CRT_ORDER, H5_ITER_NATIVE, &n, &parseParameter, &parameterMap));
      latticeWriteInterval = atof(parameterMap["latticeWriteInterval"].c_str());

      cout << "      LWI: " << latticeWriteInterval << endl;
      

      // Read info about site names (for now, we just name them 0,1,2...)
      for(int i = 0; i < numberSiteTypes; i++) {
        char buf[64];
        snprintf(buf,64,"Site.%d",i);
        siteNames.push_back(buf);
      }
      // Read info about specie names
      std::istringstream ss(parameterMap["speciesNames"]);
      string token;
	  int particleN = 1;
      while(getline(ss, token, ',')) {
          particleNames.push_back(token);
          particleNumbers.push_back(particleN++);
      }
      cout << "    Parameters read" << endl;

      // Count number of timesteps
      cout << "    Finding longest simulation..." << endl;
      H5Giterate(file, "/Simulations", NULL, &findLongest, &numberTimesteps );
      cout << "     " << numberTimesteps << " timesteps" << endl;
      cout << "    Longest found" << endl;

      // Close groups we no longer need
      if(parametersGroup != H5I_INVALID_HID) {
        HDF5_EXCEPTION_CHECK(H5Gclose(parametersGroup));
        parametersGroup   = H5I_INVALID_HID;
      }
      if(modelGroup != H5I_INVALID_HID) {
        HDF5_EXCEPTION_CHECK(H5Gclose(modelGroup));
        modelGroup        = H5I_INVALID_HID;
      }
      if(simulationsGroup != H5I_INVALID_HID) {
        HDF5_EXCEPTION_CHECK(H5Gclose(simulationsGroup));
        simulationsGroup  = H5I_INVALID_HID;
      }

      // Close the file
      if(file != H5I_INVALID_HID) {
        HDF5_EXCEPTION_CHECK(H5Fclose(file));
        file = H5I_INVALID_HID;
      }

      // Indicate that the file has been initialized 
      initialized=true;
      cout << "  Initialized" << endl;
    }
}

// ****************************************************************************
//  Method: avtLatticeMicrobesFileFormat::GetCycles
//
//  Purpose:
//      Gets the cycle numbers
//
//  Programmer: jpeterson -- generated by xml2avt
//  Creation:   Thu Jan 22 13:02:57 PST 2015
//
// ****************************************************************************
void avtLatticeMicrobesFileFormat::GetCycles(std::vector<int> &cycles)
{
  cout << "Getting cycles..." << endl;
  Initialize();

  if(hasSimulationData) {
    // Find which replicate has the most timesteps
    for(int i = 0; i < numberTimesteps; i++) cycles.push_back(i);
  }
  else {
    // Only the simulation setup was found, only one thing to show
    cycles.push_back(0);
  }
  cout << "Cycles extracted" << endl;
}

herr_t findLongest(hid_t group_id, const char *member_name, void *op_data) {
  int *maxCycles = (int *)op_data;

  // Open the group
  hid_t replicateGroup;
  HDF5_EXCEPTION_CALL(replicateGroup, H5Gopen2(group_id, member_name, H5P_DEFAULT));
  size_t size;
  H5T_class_t type;
  hsize_t dims[1];
  HDF5_EXCEPTION_CHECK(H5LTget_dataset_info(replicateGroup, "LatticeTimes", dims, &type, &size));

  // Set if max number of cycles
  if((int)(dims[0]) > (*maxCycles)) {
    (*maxCycles) = dims[0];
  }

  // Close group
  if(replicateGroup != H5I_INVALID_HID) {
    HDF5_EXCEPTION_CHECK(H5Gclose(replicateGroup));
    replicateGroup = H5I_INVALID_HID;
  }

  // Indicate that the iterator can continue
  return 0;
}

// ****************************************************************************
//  Method: avtLatticeMicrobesFileFormat::GetTimes
//
//  Purpose:
//      Gets the times associated with each cycle
//
//  Programmer: jpeterson -- generated by xml2avt
//  Creation:   Thu Jan 22 13:02:57 PST 2015
//
// ****************************************************************************
void avtLatticeMicrobesFileFormat::GetTimes(std::vector<double> &times)
{
  cout << "Getting times..." << endl;
  Initialize();
  if(hasSimulationData) {
    // Find number of timesteps for longest simulation
    for(int i = 0; i < numberTimesteps; i++) {
      times.push_back(latticeWriteInterval*i);
    }
  }
  else {
    // Only the simulation setup was found, only one thing to show
    times.push_back(-666.0);
  }
  cout << "Times extracted" << endl;



      // Print out parameter strings
      cout << "Printing parameters" << endl;
      for(map<string,string>::iterator it = parameterMap.begin(); it != parameterMap.end(); it++) {
        cout << it->first << ":" << it->second << endl;
      }

  // print all the particle/site names
  for(int i = 0; i < particleNames.size(); i++) {
    cout << "P" << i << ": " << particleNames[i] << endl;
  }
  // print all the particle/site names
  for(int i = 0; i < siteNames.size(); i++) {
    cout << "S" << i << ": " << siteNames[i] << endl;
  }

}





// ****************************************************************************
//  Method: avtEMSMDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: jpeterson -- generated by xml2avt
//  Creation:   Wed Jan 28 16:20:52 PST 2015
//
// ****************************************************************************
int
avtLatticeMicrobesFileFormat::GetNTimesteps(void)
{
  cout << "Getting count timesteps..." << endl;
  Initialize();
  if(!hasSimulationData) {
    return 1;
  } else {
    // Get the number of timesteps from the longest replicate
    cout << "  Timestep count: " << numberTimesteps << endl;
    return numberTimesteps;
  }
}


// ****************************************************************************
//  Method: avtLatticeMicrobesFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: jpeterson -- generated by xml2avt
//  Creation:   Wed Jan 28 16:20:52 PST 2015
//
// ****************************************************************************

void
avtLatticeMicrobesFileFormat::FreeUpResources(void)
{
  cout << "Freeing resources." << endl;
}


// ****************************************************************************
//  Method: avtLatticeMicrobesFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: jpeterson -- generated by xml2avt
//  Creation:   Wed Jan 28 16:20:52 PST 2015
//
// ****************************************************************************

void
avtLatticeMicrobesFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
    cout << "Populating metadata @" << timeState << endl;
    // If the file has not yet been opened, open it
    Initialize();

    // Define the basic mesh for the simulation
    //  Currently our mesh is just one big block, later we may want to be able to decompose it via processor
    avtMeshMetaData *mmd = new avtMeshMetaData;
    mmd->name = "Sites";
    mmd->spatialDimension = 3;
    mmd->topologicalDimension = 3;
    mmd->meshType = AVT_RECTILINEAR_MESH;
    mmd->numBlocks = 1;
    md->Add(mmd);


    // Define the metadata for the site types represented on the grid
    std::vector<avtScalarMetaData *> siteTypeMeta;
    /*
    for(int i = 0; i < numberSiteTypes; i++) {
      avtScalarMetaData *smd = new avtScalarMetaData;
      smd->name = siteNames[i].c_str();
      smd->meshName = "Sites";
      smd->centering = AVT_ZONECENT;
      smd->hasUnits = false;

      siteTypeMeta.push_back(smd);
    }
    */
    avtScalarMetaData *stmd= new avtScalarMetaData;
    stmd->name = "SiteTypes";
    stmd->meshName = "Sites";
    stmd->centering = AVT_ZONECENT;
    stmd->hasUnits = false;
    siteTypeMeta.push_back(stmd);


    // Define the metadata for the particles represented on the grid (e.g. as particle counts)
    std::vector<avtScalarMetaData *> particleGridMeta;
    for(int i = 0; i < numberSpecies; i++) {
      avtScalarMetaData *smd = new avtScalarMetaData;
      smd->name = particleNames[i].c_str(); 
      smd->meshName = "Sites";
      smd->centering = AVT_ZONECENT;
      smd->hasUnits = false;

      particleGridMeta.push_back(smd);
    }

    // Add site type meta deta to the metadata server
    for(int i = 0; i < siteTypeMeta.size(); i++) {
      md->Add(siteTypeMeta[i]);
    }
    //// Add particle grid meta deta to the metadata server
    for(int i = 0; i < numberSpecies; i++) {
      md->Add(particleGridMeta[i]);
    }


    // Occupancy particle names (NOTE: Using the old way, as opposed to for particle grid data
	avtScalarMetaData *omd = new avtScalarMetaData;
    omd->name = "SiteOccupancy";
    omd->meshName = "Sites";
    omd->centering = AVT_ZONECENT;
    omd->hasUnits = false;
	md->Add(omd);


    cout << "Metadata populated" << endl;
    return;  // To demonstrate the end of the function



    //
    // CODE TO ADD A MESH
    //
    // string meshname = ...
    //
    // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
    // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
    // avtMeshType mt = AVT_RECTILINEAR_MESH;
    //
    // int nblocks = YOU_MUST_DECIDE;
    // int block_origin = 0;
    // int spatial_dimension = 2;
    // int topological_dimension = 2;
    // double *extents = NULL;
    //
    // Here's the call that tells the meta-data object that we have a mesh:
    //
    // AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
    //                   spatial_dimension, topological_dimension);
    //

    //
    // CODE TO ADD A SCALAR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddScalarVarToMetaData(md, varname, mesh_for_this_var, cent);
    //

    //
    // CODE TO ADD A VECTOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int vector_dim = 2;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddVectorVarToMetaData(md, varname, mesh_for_this_var, cent,vector_dim);
    //

    //
    // CODE TO ADD A TENSOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int tensor_dim = 9;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddTensorVarToMetaData(md, varname, mesh_for_this_var, cent,tensor_dim);
    //

    //
    // CODE TO ADD A MATERIAL
    //
    // string mesh_for_mat = meshname; // ??? -- could be multiple meshes
    // string matname = ...
    // int nmats = ...;
    // vector<string> mnames;
    // for (int i = 0 ; i < nmats ; i++)
    // {
    //     char str[32];
    //     sprintf(str, "mat%d", i);
    //     -- or -- 
    //     strcpy(str, "Aluminum");
    //     mnames.push_back(str);
    // }
    // 
    // Here's the call that tells the meta-data object that we have a mat:
    //
    // AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
    //
    //
    // Here's the way to add expressions:
    //Expression momentum_expr;
    //momentum_expr.SetName("momentum");
    //momentum_expr.SetDefinition("{u, v}");
    //momentum_expr.SetType(Expression::VectorMeshVar);
    //md->AddExpression(&momentum_expr);
    //Expression KineticEnergy_expr;
    //KineticEnergy_expr.SetName("KineticEnergy");
    //KineticEnergy_expr.SetDefinition("0.5*(momentum*momentum)/(rho*rho)");
    //KineticEnergy_expr.SetType(Expression::ScalarMeshVar);
    //md->AddExpression(&KineticEnergy_expr);
    //
}


// ****************************************************************************
//  Method: avtLatticeMicrobesFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: jpeterson -- generated by xml2avt
//  Creation:   Wed Jan 28 16:20:52 PST 2015
//
// ****************************************************************************

vtkDataSet *
avtLatticeMicrobesFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
    cout << "Getting mesh: " << meshname << " in: " << domain << " @" << timestate << "..." << endl;
    // If the file has not yet been opened, open it
    Initialize();

    // Error checking for lattice dimension
    if(latticeXSize < 1 || latticeYSize < 1 || latticeZSize < 1 || latticeSpacing <= 0.0f) {
      std::ostringstream ostr;
      ostr << "One of the lattice sizes or the lattice spacings is invalid: (" << latticeXSize << "," << latticeYSize << "," << latticeZSize << ") @ " << latticeSpacing;
      EXCEPTION1(InvalidVariableException, ostr.str().c_str());
    }

    // Compute grid dimensions
    uint ndims = 0;
    if(latticeXSize > 1)
      ndims++;
    if(latticeYSize > 1)
      ndims++;
    if(latticeZSize > 1)
      ndims++;

    // Creating Grid Dimensions //
    //////////////////////////////
    int dims[3] = {1,1,1};
    vtkFloatArray *coords[3] = {0,0,0};
    dims[0] = latticeZSize + 1;
    dims[1] = latticeYSize + 1;
    dims[2] = latticeXSize + 1;
    // X
    coords[0] = vtkFloatArray::New();
    coords[0]->SetNumberOfTuples(dims[0]);
    float *xarray = (float*)coords[0]->GetVoidPointer(0);
    for(int i = 0; i < dims[0]; i++) {
      xarray[i] = i*latticeSpacing;
    }
    if(ndims > 1) {
      // Y
      coords[1] = vtkFloatArray::New();
      coords[1]->SetNumberOfTuples(dims[1]);
      float *yarray = (float*)coords[1]->GetVoidPointer(0);
      for(int i = 0; i < dims[1]; i++) {
        yarray[i] = i*latticeSpacing;
      }
      // 3D Domain
      if(ndims > 2) {
        // Z
        coords[2] = vtkFloatArray::New();
        coords[2]->SetNumberOfTuples(dims[2]);
        float *zarray = (float*)coords[2]->GetVoidPointer(0);
        for(int i = 0; i < dims[2]; i++) {
          zarray[i] = i*latticeSpacing;
        }
      } else {
        // Set Z to be a single point wide
        coords[2]->SetNumberOfTuples(1);
        coords[2]->SetComponent(0,0, 0.0f);
      }
    } else {
      // Set Y and Z to be a single point wide
      coords[1]->SetNumberOfTuples(1);
      coords[1]->SetComponent(0,0, 0.0f);
      coords[2]->SetNumberOfTuples(1);
      coords[2]->SetComponent(0,0, 0.0f);
    }


    // Create VisIt Grid //
    ///////////////////////
    vtkRectilinearGrid *rectGrid = vtkRectilinearGrid::New();
    rectGrid->SetDimensions(dims);
    rectGrid->SetXCoordinates(coords[0]);
    rectGrid->SetYCoordinates(coords[1]);
    rectGrid->SetZCoordinates(coords[2]);

    // Memory manage: I Don't know why we do this, but it was in the manual "GettingDAtaIntoVisIt2.0.0.pdf"
    coords[0]->Delete();
    coords[1]->Delete();
    coords[2]->Delete();

    // Return the shiny new grid
    cout << "Mesh extracted" << endl;
    return rectGrid;
}


// ****************************************************************************
//  Method: avtLatticeMicrobesFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: jpeterson -- generated by xml2avt
//  Creation:   Wed Jan 28 16:20:52 PST 2015
//
// ****************************************************************************

vtkDataArray *
avtLatticeMicrobesFileFormat::GetVar(int timestate, int domain, const char *varname)
{
    cout << "Getting variable: " << endl;
    cout << varname << " in: " << domain << " @" << timestate << "..." << endl;
    Initialize();

    // Create the data array 
	int nvalues = latticeXSize * latticeYSize * latticeZSize;
        
    vtkFloatArray *arr = vtkFloatArray::New();
    arr->SetNumberOfTuples(nvalues);
    float *data = (float *)arr->GetVoidPointer(0);

    int varIdx       = -1; // Index into the array for the variable
    bool isSite      = false;
    bool isParticle  = false;
    bool isOccupancy = false;

    // Determine if it is a site variable
    if(strcmp(varname, "SiteTypes") == 0) {
      isSite = true;
    }
    // Determine if it is a particle variable
    for(int i = 0; i < particleNames.size(); i++) {
      if(particleNames[i].compare(string(varname)) == 0) {
        varIdx = i;
        isParticle = true;
		cout << "Variable Idx: " << varIdx << endl;
        break;
      }
    }

    // Check if it is one of the special defined variables
    if(strcmp(varname,"SiteOccupancy") == 0)
      isOccupancy = true;

    // Actually read the variable
    if(isSite) {
       readSiteData(data, varname);
    } else if(isParticle) {
       readParticleData(data, timestate, domain, varIdx, varname);
    } else if(isOccupancy) {
       readOccupancyData(data, timestate, domain, varname);
    } else {
      EXCEPTION1(InvalidVariableException, varname);
    }

    cout << "Variable extracted" << endl;
    return arr;

    //
    // If you do have a scalar variable, here is some code that may be helpful.
    //
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // rv->SetNumberOfTuples(ntuples);
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      rv->SetTuple1(i, VAL);  // you must determine value for ith entry.
    // }
    //
    // return rv;
    //
}

// Read the site locations
void avtLatticeMicrobesFileFormat::readSiteData(float *data, const char *varname) 
{
  cout << "  Reading Lattice Site Types..." << endl;

  // Open file for reading
  HDF5_EXCEPTION_CALL(file,H5Fopen(filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT));

  // Get dataset size
  int ndims;
  hsize_t dims[4];
  H5T_class_t type;
  size_t size;
  // Get number odf dimensions in the LatticeSites
  HDF5_EXCEPTION_CHECK(H5LTget_dataset_ndims(file, "/Model/Diffusion/LatticeSites", &ndims));

  // Get LatticeSites info
  HDF5_EXCEPTION_CHECK(H5LTget_dataset_info(file, "/Model/Diffusion/LatticeSites", dims, &type, &size));

  // Read the lattice matrix
  uint latticeSize = latticeXSize*latticeYSize*latticeZSize;
  uint8_t *intDataSet = new uint8_t[latticeSize];
  HDF5_EXCEPTION_CHECK(H5LTread_dataset(file, "/Model/Diffusion/LatticeSites", H5T_NATIVE_UINT8, intDataSet));

  // Copy and convert data types
  for(int i = 0; i < latticeSize; i++) {
    data[i] = (float)intDataSet[i];
  }

  // Clean up our temporary
  delete [] intDataSet;

  // Close file
  if(file != H5I_INVALID_HID) {
    HDF5_EXCEPTION_CHECK(H5Fclose(file));
    file = H5I_INVALID_HID;
  }

  cout << "  Lattice Sites read" << endl; 
}

// Read the particle counts
void avtLatticeMicrobesFileFormat::readParticleData(float *data, int timestate, int domain, int varIdx, const char *varname) 
{
  cout << "  Reading " << varname << " @" << timestate << " in domain: " << domain << "..." << endl;
  // Open file for reading
  HDF5_EXCEPTION_CALL(file, H5Fopen(filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT));

  // Get the particle number
  int pNum = varIdx + 1;

  // Dataset size
  int ndims;
  hsize_t dims[4];
  H5T_class_t type;
  size_t size;
  // Dataset representation
  uint latticeSize = latticeXSize*latticeYSize*latticeZSize;
  uint bufferSize  = latticeSize*particlesPerSite;
  uint8_t *intDataSet = new uint8_t[bufferSize];

  // If this is the initial timestep
  if(!hasSimulationData) {
	cout << "  Reading particles from initial condition." << endl;
    // Get number of dimensions in the LatticeSites
    HDF5_EXCEPTION_CHECK(H5LTget_dataset_ndims(file, "/Model/Diffusion/Lattice", &ndims));
  
    // Get LatticeSites info
    HDF5_EXCEPTION_CHECK(H5LTget_dataset_info(file, "/Model/Diffusion/Lattice", dims, &type, &size));
  
    // Read the lattice matrix
    HDF5_EXCEPTION_CHECK(H5LTread_dataset(file, "/Model/Diffusion/Lattice", H5T_STD_U8LE, intDataSet));
  } else { // read for the current timestep
    // Construct the path to the current lattice
    cout << "  Reading particles from current timestep." << endl;
    char path[1024];
    snprintf(path, 1023, "/Simulations/%07d/Lattice/%010d", domain+1, timestate); 
    cout << "Path: " << path << endl;

    // Get number of dimensions in the LatticeSites
    HDF5_EXCEPTION_CHECK(H5LTget_dataset_ndims(file, path, &ndims));

    // Get LatticeSites info
    HDF5_EXCEPTION_CHECK(H5LTget_dataset_info(file, path, dims, &type, &size));

    // Read the lattice matrix
    HDF5_EXCEPTION_CHECK(H5LTread_dataset(file, path, H5T_STD_U8LE, intDataSet));
  }

  // Clear the buffer
  memset(data, 0, latticeSize*sizeof(float));

  // Create the correct dataset
  int idx = 0;
  for(int w = 0; w < wordsPerSite; w++) {
    for(int z = 0; z < latticeZSize; z++) {
      for(int y = 0; y < latticeYSize; y++) {
        for(int x = 0; x < latticeXSize; x++) {
          // Count number of particles
          float pCount = 0.0f;
       	  uint sourceIdx = x*latticeYSize*latticeZSize*particlesPerSite + y*latticeZSize*particlesPerSite + z*particlesPerSite + w*PARTICLES_PER_WORD;
          
          for(int p = 0; p < PARTICLES_PER_WORD; p++) {
            if( intDataSet[sourceIdx+p] == pNum)
              pCount += 1.0f;
          }
          data[z + (y*latticeZSize) + (x*latticeZSize*latticeYSize)] += (float)pCount;
        }
      }
    }
  }

  // Clean up our temporary
  delete [] intDataSet;
 

  // Close file
  if(file != H5I_INVALID_HID) {
    HDF5_EXCEPTION_CHECK(H5Fclose(file));
    file = H5I_INVALID_HID;
  }

  cout << "  Variable Read" << endl;
}

// Read the occupancy data
void avtLatticeMicrobesFileFormat::readOccupancyData(float *data, int timestate, int domain, const char *varname) 
{
  cout << "  Reading " << varname << " @" << timestate << " in domain: " << domain << "..." << endl;
  // Open file for reading
  HDF5_EXCEPTION_CALL(file, H5Fopen(filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT));

  // Get the particle number
  int ndims;
  hsize_t dims[4];
  H5T_class_t type;
  size_t size;
  // Dataset representation
  uint latticeSize = latticeXSize*latticeYSize*latticeZSize;
  uint bufferSize  = latticeSize*particlesPerSite;
  uint8_t *intDataSet = new uint8_t[bufferSize];

  // If this is the initial timestep
  if(!hasSimulationData) {
    cout << "  Reading occupancy from initial condition." << endl;
    // Get number of dimensions in the LatticeSites
    HDF5_EXCEPTION_CHECK(H5LTget_dataset_ndims(file, "/Model/Diffusion/LatticeSites", &ndims));

    // Get LatticeSites info
    HDF5_EXCEPTION_CHECK(H5LTget_dataset_info(file, "/Model/Diffusion/LatticeSites", dims, &type, &size));

    // Read the lattice matrix
    HDF5_EXCEPTION_CHECK(H5LTread_dataset(file, "/Model/Diffusion/LatticeSites", H5T_STD_U8LE, intDataSet));
  } else { // read for the current timestep
    // Construct the path to the current lattice
    cout << "  Reading occupancy from current timestep." << endl;
    char path[1024];
    snprintf(path, 1023, "/Simulations/%07d/Lattice/%010d", domain+1, timestate);
    cout << "Path: " << path << endl;

    // Get number of dimensions in the LatticeSites
    HDF5_EXCEPTION_CHECK(H5LTget_dataset_ndims(file, path, &ndims));

    // Get LatticeSites info
    HDF5_EXCEPTION_CHECK(H5LTget_dataset_info(file, path, dims, &type, &size));

    // Read the lattice matrix
    HDF5_EXCEPTION_CHECK(H5LTread_dataset(file, path, H5T_STD_U8LE, intDataSet));
  }

  // Clear the buffer
  memset(data, 0, latticeSize*sizeof(float));

  // Create the correct dataset
  int idx = 0;
  for(int w = 0; w < wordsPerSite; w++) {
    for(int z = 0; z < latticeZSize; z++) {
      for(int y = 0; y < latticeYSize; y++) {
        for(int x = 0; x < latticeXSize; x++) {
          // Count number of particles
          float pCount = 0.0f;
          uint sourceIdx = x*latticeYSize*latticeZSize*particlesPerSite + y*latticeZSize*particlesPerSite + z*particlesPerSite + w*PARTICLES_PER_WORD;

          for(int p = 0; p < PARTICLES_PER_WORD; p++) {
            if( intDataSet[sourceIdx+p] != 0)
              pCount += 1.0f/particlesPerSite;
          }
          data[z + (y*latticeZSize) + (x*latticeZSize*latticeYSize)] += (float)pCount;
        }
      }
    }
  }

  // Clean up our temporary
  delete [] intDataSet;


  // Close file
  if(file != H5I_INVALID_HID) {
    HDF5_EXCEPTION_CHECK(H5Fclose(file));
    file = H5I_INVALID_HID;
  }

  cout << "  Variable Read" << endl;
}








// ****************************************************************************
//  Method: avtLatticeMicrobesFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: jpeterson -- generated by xml2avt
//  Creation:   Wed Jan 28 16:20:52 PST 2015
//
// ****************************************************************************

vtkDataArray *
avtLatticeMicrobesFileFormat::GetVectorVar(int timestate, int domain,const char *varname)
{
    cout << "Getting vector: " << varname << " in: " << domain << " @" << timestate << "..." << endl;
    Initialize();
    cout << "Vector extracted" << endl;

    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
}



/////////////////////////////////
// Protected/Private Functions //
/////////////////////////////////
bool avtLatticeMicrobesFileFormat::sufficientLibraryCapabilities() {
  unsigned int filterInfo;

  // Check that GZIP is supported
  if( !H5Zfilter_avail(H5Z_FILTER_DEFLATE) ) {
    cout << "ERROR: HDF5 library doesn't support gzip compression." << endl;
    return false;
  }
  // Check that the filter info could be recieved
  if( H5Zget_filter_info(H5Z_FILTER_DEFLATE, &filterInfo) < 0 ) {
    cout << "ERROR: filter info bad." << endl;
    return false;
  }
  // Check taht the libray supports filtering in decoding
  if( !(filterInfo & H5Z_FILTER_CONFIG_DECODE_ENABLED) ) {
    cout << "ERROR: HDF5 library doesn't support filter decoding." << endl;
    return false;

  }

  return true;
}

bool avtLatticeMicrobesFileFormat::isFileValid(const char *filename, char *errMsg, int bufferSize) {
  char localBuffer[64];
  cout << "    Checking file: " << filename << " validity..." << endl;
  // Check for the LM magic number
  cout << "      Opening file..." << endl;
  FILE *fp = fopen(filename, "r");
  if(fp == NULL) {
    strncat(errMsg, "File doesn't exist: ", bufferSize);
    strncat(errMsg, filename, bufferSize);
    return false;
  }
  char magic[5];
  magic[4] = '\0';
  for(int i = 0; i < 4; i++) {
    magic[i] = fgetc(fp);
    if(magic[i] == EOF) {
       magic[i] == '\0';
       break;
    }
  }
  cout << "      Closing file..." << endl;
  if(fclose(fp) != 0) {
    strncat(errMsg, "File couldn't be closed: ", bufferSize);
    strncat(errMsg, filename, bufferSize);
    return false;
  }
  cout << "      Checking magic number..." << endl;
  if(strncmp(magic, "LMH5",4) != 0) {
    strncat(errMsg, "Not a valid LM file, given code: ", bufferSize);
    strncat(errMsg, magic, bufferSize);
    return false;
  }
  bool isHDFfile = false;
  HDF5_EXCEPTION_CALL(isHDFfile, H5Fis_hdf5(filename));
  if(!isHDFfile) {
    strncat(errMsg, "Not an HDF5 file.", bufferSize);
    return false;
  }

  cout << "    File valid" << endl;
  return true;
}


herr_t parseParameter(hid_t location_id, const char *attr_name, const H5A_info_t *ainfo, void *op_data) {
  cout << "      Parsing parameters..." << endl;
  map<string,string> * paramMap = reinterpret_cast<map<string,string> *>(op_data);


  // local variables
  hid_t attr;
  hid_t type;
  H5T_class_t typeClass;
  hsize_t size;

  // Open the location
  HDF5_EXCEPTION_CALL(attr      , H5Aopen(location_id, attr_name, H5P_DEFAULT));
  HDF5_EXCEPTION_CALL(type      , H5Aget_type(attr));
  typeClass = H5Tget_class(type);
  HDF5_EXCEPTION_CALL(size      , H5Aget_storage_size(attr));
  // Floating Point value
  if(typeClass == H5T_FLOAT && size == sizeof(double)) {
    double value;
    char buffer[33];
    HDF5_EXCEPTION_CHECK(H5Aread(attr, H5T_NATIVE_DOUBLE, &value));
    snprintf(buffer, sizeof(buffer), "%g", value);

    (*paramMap)[attr_name] = buffer;
  } else if(typeClass == H5T_STRING) { // String value
    // get dataspace
    hid_t space;
    HDF5_EXCEPTION_CALL(space , H5Aget_space(attr));

    // create memory datatype
    hid_t memtype;
    HDF5_EXCEPTION_CALL(memtype , H5Tcopy(H5T_C_S1));
    HDF5_EXCEPTION_CHECK(H5Tset_size(memtype, size));

    // read data
    char *value = new char[size];
    HDF5_EXCEPTION_CHECK(H5Aread(attr, memtype, value));

    // add parameter to map
    (*paramMap)[attr_name] = value;

    // reclaim memory and close HDF handles
    delete [] value;
    HDF5_EXCEPTION_CHECK(H5Tclose(memtype));
    HDF5_EXCEPTION_CHECK(H5Sclose(space));
  }
  // Close HDF Handles
  HDF5_EXCEPTION_CHECK(H5Tclose(type));
  HDF5_EXCEPTION_CHECK(H5Aclose(attr));
  cout << "      Parameters parsed" << endl;
  return 0;
}





